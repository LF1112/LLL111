<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>封装函数</title>
    <script>
        const arr=[9,1,3,2,8,0,5,7,6,4]
        const arr2=[9,8,7,6,5,4,3,2,1]

        /* 
         for(i=0;i<arr.length;i++){
            for(j=0;j<arr.length;j++){
                if(arr[i]>arr[j]){
                    let temp=arr[i]
                    arr[i]=arr[j]
                    arr[j]=temp
                }
            }
        }
         //但是，这段代码是专门为这个数组存在的,因为数组arr是固定的，换了arr2就不能运行
         //如存在：
         const arr2=[]
         console.log(arr) 
         */

        /*
         因为我们需要这个代码反复被调用，所以此时把它封装到一个函数中即可 
         故此时需要使用函数
         但因为此时里面的变量还是arr，所以此时需要定义一个参数
         定义一个形参arr
         因为函数中存在参数就找函数中的函数作用域
         */

         /* 
          function sort(arr){
            for(i=0;i<arr.length;i++){
            for(j=0;j<arr.length;j++){
                if(arr[i]>arr[j]){
                    let temp=arr[i]
                    arr[i]=arr[j]
                    arr[j]=temp
                 }
             }
           }
         }
         //sort()//没传参就报错，因为函数循环中的arr为函数的参数，没传即没有
         sort(arr)
         console.log(arr) 
         */
         //因为改变了原本的数组，所以此方法为破坏性方法
         
         //为了不破坏原数组可以：
         function sort(array){
            const arr =array.slice()//浅复制，相当于把传进来的数组浅复制给了变量arr
            //等价于const.arr=[...array]这样下面的所有操作都是对复制的数组进行操作，没有破坏原数组
            for(i=0;i<arr.length;i++){
            for(j=0;j<arr.length;j++){
                if(arr[i]>arr[j]){
                    let temp=arr[i]
                    arr[i]=arr[j]
                    arr[j]=temp
                 }
             }
           }
           //但是此时返回的是原数组而不是复制的数组
           //所以需要将函数的参数作为返回值返回
           return arr
         }
         let result=sort(arr)//接收一下
        //  console.log(arr) 
        //  console.log(result)


        class Person {
            constructor(name,age){
                this.name = name
                this.age = age
            }
        }

        const personArr =[
        new Person("孙悟空",18),
        new Person("沙和尚",38),
        new Person("红孩儿",8),
       ]
    //由于这个函数也局限所以可以用封装函数
    //filter()函数用来对数组进行过滤
    function filter(arr){
        //此时再创建一个新的数组将符合条件的放入新数组中
        const newArr=[]
        for(let i=0; i<arr.length; i++){
        if(arr[i].age < 18){
            //console.log(arr[i])
            newArr.push(arr[i])
          }
        }
      return newArr
    }
   //filter(personArr)此时没有任何打印而是返回一个结果
   const result2=filter(personArr)
   console.log(result2)

    </script>
</head>
<body>
    
</body>
</html>